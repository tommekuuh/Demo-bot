"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @module botbuilder-ai
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
const cognitiveservices_luis_runtime_1 = require("@azure/cognitiveservices-luis-runtime");
const msRest = require("@azure/ms-rest-js");
const botbuilder_core_1 = require("botbuilder-core");
const os = require("os");
const Url = require("url-parse");
const luisTelemetryConstants_1 = require("./luisTelemetryConstants");
const pjson = require('../package.json');
const LUIS_TRACE_TYPE = 'https://www.luis.ai/schemas/trace';
const LUIS_TRACE_NAME = 'LuisRecognizer';
const LUIS_TRACE_LABEL = 'Luis Trace';
/**
 * Recognize intents in a user utterance using a configured LUIS model.
 *
 * @remarks
 * This class is used to recognize intents and extract entities from incoming messages.
 * See this class in action [in this sample application](https://github.com/Microsoft/BotBuilder-Samples/tree/master/samples/javascript_nodejs/12.nlp-with-luis).
 *
 * This component can be used within your bots logic by calling [recognize()](#recognize).
 */
class LuisRecognizer {
    constructor(application, options, includeApiResults) {
        this.cacheKey = Symbol('results');
        if (typeof application === 'string') {
            const parsedEndpoint = Url(application);
            // Use exposed querystringify to parse the query string for the endpointKey value.
            const parsedQuery = Url.qs.parse(parsedEndpoint.query);
            this.application = {
                applicationId: parsedEndpoint.pathname.split('apps/')[1],
                // Note: The query string parser bundled with url-parse can return "null" as a value for the origin.
                endpoint: parsedEndpoint.origin,
                endpointKey: parsedQuery['subscription-key']
            };
        }
        else {
            const { applicationId, endpoint, endpointKey } = application;
            this.application = {
                applicationId: applicationId,
                endpoint: endpoint,
                endpointKey: endpointKey
            };
        }
        this.validateLuisApplication();
        this.options = {
            includeAllIntents: false,
            includeInstanceData: true,
            log: true,
            spellCheck: false,
            staging: false,
            ...options
        };
        this.includeApiResults = !!includeApiResults;
        // Create client
        // - We have to cast "creds as any" to avoid a build break relating to different versions
        //   of autorest being used by our various components.  This is just a build issue and
        //   shouldn't effect production bots.
        const creds = new msRest.TokenCredentials(this.application.endpointKey);
        const baseUri = this.application.endpoint || 'https://westus.api.cognitive.microsoft.com';
        this.luisClient = new cognitiveservices_luis_runtime_1.LUISRuntimeClient(creds, baseUri);
        this._telemetryClient = this.options.telemetryClient || new botbuilder_core_1.NullTelemetryClient();
        this._logPersonalInformation = this.options.logPersonalInformation || false;
    }
    /**
     * Gets a value indicating whether determines whether to log personal information that came from the user.
     */
    get logPersonalInformation() { return this._logPersonalInformation; }
    /**
      * Gets the currently configured botTelemetryClient that logs the events.
      */
    get telemetryClient() { return this._telemetryClient; }
    /**
     * Returns the name of the top scoring intent from a set of LUIS results.
     * @param results Result set to be searched.
     * @param defaultIntent (Optional) intent name to return should a top intent be found. Defaults to a value of `None`.
     * @param minScore (Optional) minimum score needed for an intent to be considered as a top intent. If all intents in the set are below this threshold then the `defaultIntent` will be returned.  Defaults to a value of `0.0`.
     */
    static topIntent(results, defaultIntent = 'None', minScore = 0) {
        let topIntent;
        let topScore = -1;
        if (results && results.intents) {
            // for (const name in results.intents) {
            Object.keys(results.intents).forEach((name) => {
                const score = results.intents[name].score;
                if (typeof score === 'number' && score > topScore && score >= minScore) {
                    topIntent = name;
                    topScore = score;
                }
            });
        }
        return topIntent || defaultIntent;
    }
    /**
     * Calls LUIS to recognize intents and entities in a users utterance.
     * @remarks
     * Returns a [RecognizerResult](../botbuilder-core/recognizerresult) containing any intents and entities recognized by LUIS.
     *
     * In addition to returning the results from LUIS, [recognize()](#recognize) will also
     * emit a trace activity that contains the LUIS results.
     *
     * Here is an example of recognize being used within a bot's turn handler: to interpret an incoming message:
     *
     * ```javascript
     * async onTurn(context) {
     *     if (turnContext.activity.type === ActivityTypes.Message) {
     *         const results = await luisRecognizer.recognize(turnContext);
     *         const topIntent = LuisRecognizer.topIntent(results);
     *         switch (topIntent) {
     *             case 'MyIntent':
     *                 // ... handle intent ...
     *                 break;
     *             case 'None':
     *                 // ... handle intent ...
     *                 break;
     *         }
     *     }
     * }
     * ```
     * @param context Context for the current turn of conversation with the use.
     * @param telemetryProperties Additional properties to be logged to telemetry with the LuisResult event.
     * @param telemetryMetrics Additional metrics to be logged to telemetry with the LuisResult event.
     * @param options (Optional) options object used to control predictions. Should conform to the [LuisPrectionOptions](#luispredictionoptions) definition.
     */
    recognize(context, telemetryProperties, telemetryMetrics, options) {
        const cached = context.turnState.get(this.cacheKey);
        const luisPredictionOptions = options ? this.setLuisPredictionOptions(this.options, options) : this.options;
        if (!cached) {
            const utterance = context.activity.text || '';
            let recognizerPromise;
            if (!utterance.trim()) {
                // Bypass LUIS if the activity's text is null or whitespace
                recognizerPromise = Promise.resolve({
                    text: utterance,
                    intents: { '': { score: 1 } },
                    entities: {},
                });
            }
            else {
                recognizerPromise = this.luisClient.prediction.resolve(this.application.applicationId, utterance, {
                    verbose: luisPredictionOptions.includeAllIntents,
                    customHeaders: {
                        'Ocp-Apim-Subscription-Key': this.application.endpointKey,
                        'User-Agent': this.getUserAgent()
                    },
                    ...luisPredictionOptions
                })
                    // Map results
                    .then((luisResult) => ({
                    text: luisResult.query,
                    alteredText: luisResult.alteredQuery,
                    intents: this.getIntents(luisResult),
                    entities: this.getEntitiesAndMetadata(luisResult.entities, luisResult.compositeEntities, luisPredictionOptions.includeInstanceData === undefined || luisPredictionOptions.includeInstanceData),
                    sentiment: this.getSentiment(luisResult),
                    luisResult: (this.includeApiResults ? luisResult : null)
                }));
            }
            return recognizerPromise
                .then((recognizerResult) => {
                // Write to cache
                context.turnState.set(this.cacheKey, recognizerResult);
                // Log telemetry
                this.onRecognizerResults(recognizerResult, context, telemetryProperties, telemetryMetrics);
                return this.emitTraceInfo(context, recognizerResult.luisResult || null, recognizerResult).then(() => {
                    return recognizerResult;
                });
            })
                .catch((error) => {
                this.prepareErrorMessage(error);
                throw error;
            });
        }
        return Promise.resolve(cached);
    }
    /**
     * Invoked prior to a LuisResult Event being logged.
     * @param recognizerResult The Luis Results for the call.
     * @param turnContext Context object containing information for a single turn of conversation with a user.
     * @param telemetryProperties Additional properties to be logged to telemetry with the LuisResult event.
     * @param telemetryMetrics Additional metrics to be logged to telemetry with the LuisResult event.
     */
    async onRecognizerResults(recognizerResult, turnContext, telemetryProperties, telemetryMetrics) {
        await this.fillTelemetryProperties(recognizerResult, turnContext, telemetryProperties).then(props => {
            this.telemetryClient.trackEvent({
                name: luisTelemetryConstants_1.LuisTelemetryConstants.luisResultEvent,
                properties: props,
                metrics: telemetryMetrics
            });
        });
        return;
    }
    /**
     * Fills the event properties for LuisResult event for telemetry.
     * These properties are logged when the recognizer is called.
     * @param recognizerResult Last activity sent from user.
     * @param turnContext Context object containing information for a single turn of conversation with a user.
     * @param telemetryProperties Additional properties to be logged to telemetry with the LuisResult event.
     * @returns A dictionary that is sent as properties to BotTelemetryClient.trackEvent method for the LuisResult event.
     */
    async fillTelemetryProperties(recognizerResult, turnContext, telemetryProperties) {
        const topLuisIntent = LuisRecognizer.topIntent(recognizerResult);
        const intentScore = (recognizerResult.intents[topLuisIntent] && 'score' in recognizerResult.intents[topLuisIntent]) ?
            recognizerResult.intents[topLuisIntent].score : 0;
        // Add the intent score and conversation id properties
        const properties = {};
        properties[luisTelemetryConstants_1.LuisTelemetryConstants.applicationIdProperty] = this.application.applicationId;
        properties[luisTelemetryConstants_1.LuisTelemetryConstants.intentProperty] = topLuisIntent;
        properties[luisTelemetryConstants_1.LuisTelemetryConstants.intentScoreProperty] = intentScore.toString();
        if (turnContext.activity.from) {
            properties[luisTelemetryConstants_1.LuisTelemetryConstants.fromIdProperty] = turnContext.activity.from.id;
            ;
        }
        if (recognizerResult.sentiment) {
            if (recognizerResult.sentiment.label) {
                properties[luisTelemetryConstants_1.LuisTelemetryConstants.sentimentLabelProperty] = recognizerResult.sentiment.label;
            }
            if (recognizerResult.sentiment.score) {
                properties[luisTelemetryConstants_1.LuisTelemetryConstants.sentimentScoreProperty] = recognizerResult.sentiment.score.toString();
            }
        }
        // Log entity names
        if (recognizerResult.entities) {
            properties[luisTelemetryConstants_1.LuisTelemetryConstants.entitiesProperty] = JSON.stringify(recognizerResult.entities);
        }
        // Use the LogPersonalInformation flag to toggle logging PII data, text is a common example
        if (this.logPersonalInformation && turnContext.activity.text) {
            properties[luisTelemetryConstants_1.LuisTelemetryConstants.questionProperty] = turnContext.activity.text;
        }
        // Additional Properties can override "stock" properties.
        if (telemetryProperties != null) {
            return Object.assign({}, properties, telemetryProperties);
        }
        return properties;
    }
    getUserAgent() {
        // Note when the ms-rest dependency the LuisClient uses has been updated
        // this code should be modified to use the client's addUserAgentInfo() function.
        const packageUserAgent = `${pjson.name}/${pjson.version}`;
        const platformUserAgent = `(${os.arch()}-${os.type()}-${os.release()}; Node.js,Version=${process.version})`;
        const userAgent = `${packageUserAgent} ${platformUserAgent}`;
        return userAgent;
    }
    emitTraceInfo(context, luisResult, recognizerResult) {
        const traceInfo = {
            recognizerResult: recognizerResult,
            luisResult: luisResult,
            luisOptions: {
                Staging: this.options.staging
            },
            luisModel: {
                ModelID: this.application.applicationId
            }
        };
        return context.sendActivity({
            type: 'trace',
            valueType: LUIS_TRACE_TYPE,
            name: LUIS_TRACE_NAME,
            label: LUIS_TRACE_LABEL,
            value: traceInfo
        });
    }
    prepareErrorMessage(error) {
        // If the `error` received is a azure-cognitiveservices-luis-runtime error,
        // it may have a `response` property and `response.statusCode`.
        // If these properties exist, we should populate the error with a correct and informative error message.
        if (error.response && error.response.status) {
            switch (error.response.status) {
                case 400:
                    error.message = [
                        `Response 400: The request's body or parameters are incorrect,`,
                        `meaning they are missing, malformed, or too large.`
                    ].join(' ');
                    break;
                case 401:
                    error.message = `Response 401: The key used is invalid, malformed, empty, or doesn't match the region.`;
                    break;
                case 403:
                    error.message = `Response 403: Total monthly key quota limit exceeded.`;
                    break;
                case 409:
                    error.message = `Response 409: Application loading in progress, please try again.`;
                    break;
                case 410:
                    error.message = `Response 410: Please retrain and republish your application.`;
                    break;
                case 414:
                    error.message = `Response 414: The query is too long. Please reduce the query length to 500 or less characters.`;
                    break;
                case 429:
                    error.message = `Response 429: Too many requests.`;
                    break;
                default:
                    error.message = [
                        `Response ${error.response.status}: Unexpected status code received.`,
                        `Please verify that your LUIS application is properly setup.`
                    ].join(' ');
            }
        }
    }
    normalizeName(name) {
        return name.replace(/\.| /g, '_');
    }
    getIntents(luisResult) {
        const intents = {};
        if (luisResult.intents) {
            luisResult.intents.reduce((prev, curr) => {
                prev[this.normalizeName(curr.intent)] = { score: curr.score };
                return prev;
            }, intents);
        }
        else {
            const topScoringIntent = luisResult.topScoringIntent;
            intents[this.normalizeName((topScoringIntent).intent)] = { score: topScoringIntent.score };
        }
        return intents;
    }
    getEntitiesAndMetadata(entities, compositeEntities, verbose) {
        const entitiesAndMetadata = verbose ? { $instance: {} } : {};
        let compositeEntityTypes = [];
        // We start by populating composite entities so that entities covered by them are removed from the entities list
        if (compositeEntities) {
            compositeEntityTypes = compositeEntities.map((compositeEntity) => compositeEntity.parentType);
            compositeEntities.forEach((compositeEntity) => {
                entities = this.populateCompositeEntity(compositeEntity, entities, entitiesAndMetadata, verbose);
            });
        }
        entities.forEach((entity) => {
            // we'll address composite entities separately
            if (compositeEntityTypes.indexOf(entity.type) > -1) {
                return;
            }
            let val = this.getEntityValue(entity);
            if (val != null) {
                this.addProperty(entitiesAndMetadata, this.getNormalizedEntityName(entity), val);
                if (verbose) {
                    this.addProperty(entitiesAndMetadata.$instance, this.getNormalizedEntityName(entity), this.getEntityMetadata(entity));
                }
            }
        });
        return entitiesAndMetadata;
    }
    getEntityValue(entity) {
        if (entity.type.startsWith("builtin.geographyV2.")) {
            return {
                "type": entity.type.substring(20),
                "location": entity.entity
            };
        }
        if (entity.type.startsWith('builtin.ordinalV2')) {
            return {
                "relativeTo": entity.resolution.relativeTo,
                "offset": Number(entity.resolution.offset)
            };
        }
        if (!entity.resolution) {
            return entity.entity;
        }
        if (entity.type.startsWith('builtin.datetimeV2.')) {
            if (!entity.resolution.values || !entity.resolution.values.length) {
                return entity.resolution;
            }
            const vals = entity.resolution.values;
            const type = vals[0].type;
            const timexes = vals.map((t) => t.timex);
            const distinct = timexes.filter((v, i, a) => a.indexOf(v) === i);
            return { type: type, timex: distinct };
        }
        else {
            const res = entity.resolution;
            switch (entity.type) {
                case 'builtin.number':
                case 'builtin.ordinal': return Number(res.value);
                case 'builtin.percentage':
                    {
                        let svalue = res.value;
                        if (svalue.endsWith('%')) {
                            svalue = svalue.substring(0, svalue.length - 1);
                        }
                        return Number(svalue);
                    }
                case 'builtin.age':
                case 'builtin.dimension':
                case 'builtin.currency':
                case 'builtin.temperature':
                    {
                        const val = res.value;
                        const obj = {};
                        if (val) {
                            obj.number = Number(val);
                        }
                        obj.units = res.unit;
                        return obj;
                    }
                default:
                    // This will return null if there is no value/values which can happen when a new prebuilt is introduced
                    return entity.resolution.value ?
                        entity.resolution.value :
                        entity.resolution.values;
            }
        }
    }
    getEntityMetadata(entity) {
        const res = {
            startIndex: entity.startIndex,
            endIndex: entity.endIndex + 1,
            score: entity.score,
            text: entity.entity,
            type: entity.type
        };
        if (entity.resolution && entity.resolution.subtype) {
            res.subtype = entity.resolution.subtype;
        }
        return res;
    }
    getNormalizedEntityName(entity) {
        // Type::Role -> Role
        let type = entity.type.split(':').pop();
        if (type.startsWith('builtin.datetimeV2.')) {
            type = 'datetime';
        }
        else if (type.startsWith('builtin.currency')) {
            type = 'money';
        }
        else if (type.startsWith('builtin.geographyV2')) {
            type = 'geographyV2';
        }
        else if (type.startsWith('builtin.ordinalV2')) {
            type = 'ordinalV2';
        }
        else if (type.startsWith('builtin.')) {
            type = type.substring(8);
        }
        if (entity.role !== null && entity.role !== '' && entity.role !== undefined) {
            type = entity.role;
        }
        return type.replace(/\.|\s/g, '_');
    }
    populateCompositeEntity(compositeEntity, entities, entitiesAndMetadata, verbose) {
        const childrenEntites = verbose ? { $instance: {} } : {};
        let childrenEntitiesMetadata = {};
        // This is now implemented as O(n^2) search and can be reduced to O(2n) using a map as an optimization if n grows
        const compositeEntityMetadata = entities.find((entity) => {
            // For now we are matching by value, which can be ambiguous if the same composite entity shows up with the same text
            // multiple times within an utterance, but this is just a stop gap solution till the indices are included in composite entities
            return entity.type === compositeEntity.parentType && entity.entity === compositeEntity.value;
        });
        const filteredEntities = [];
        if (verbose) {
            childrenEntitiesMetadata = this.getEntityMetadata(compositeEntityMetadata);
        }
        // This is now implemented as O(n*k) search and can be reduced to O(n + k) using a map as an optimization if n or k grow
        const coveredSet = new Set();
        compositeEntity.children.forEach((childEntity) => {
            for (let i = 0; i < entities.length; i++) {
                const entity = entities[i];
                if (!coveredSet.has(i) &&
                    childEntity.type === entity.type &&
                    compositeEntityMetadata &&
                    entity.startIndex !== undefined &&
                    compositeEntityMetadata.startIndex !== undefined &&
                    entity.startIndex >= compositeEntityMetadata.startIndex &&
                    entity.endIndex !== undefined &&
                    compositeEntityMetadata.endIndex !== undefined &&
                    entity.endIndex <= compositeEntityMetadata.endIndex) {
                    // Add to the set to ensure that we don't consider the same child entity more than once per composite
                    coveredSet.add(i);
                    let val = this.getEntityValue(entity);
                    if (val != null) {
                        this.addProperty(childrenEntites, this.getNormalizedEntityName(entity), val);
                        if (verbose) {
                            this.addProperty(childrenEntites.$instance, this.getNormalizedEntityName(entity), this.getEntityMetadata(entity));
                        }
                    }
                }
            }
        });
        // filter entities that were covered by this composite entity
        for (let i = 0; i < entities.length; i++) {
            if (!coveredSet.has(i)) {
                filteredEntities.push(entities[i]);
            }
        }
        this.addProperty(entitiesAndMetadata, this.getNormalizedEntityName(compositeEntityMetadata), childrenEntites);
        if (verbose) {
            this.addProperty(entitiesAndMetadata.$instance, this.getNormalizedEntityName(compositeEntityMetadata), childrenEntitiesMetadata);
        }
        return filteredEntities;
    }
    /**
     * If a property doesn't exist add it to a new array, otherwise append it to the existing array
     * @param obj Object on which the property is to be set
     * @param key Property Key
     * @param value Property Value
     */
    addProperty(obj, key, value) {
        if (key in obj) {
            obj[key] = obj[key].concat(value);
        }
        else {
            obj[key] = [value];
        }
    }
    getSentiment(luis) {
        let result;
        if (luis.sentimentAnalysis) {
            result = {
                label: luis.sentimentAnalysis.label,
                score: luis.sentimentAnalysis.score
            };
        }
        return result;
    }
    /**
     * Merges the default options set by the Recognizer contructor with the 'user' options passed into the 'recognize' method
    */
    setLuisPredictionOptions(defaultOptions, userOptions) {
        return Object.assign(defaultOptions, userOptions);
    }
    /**
     * Performs a series of valdiations on `LuisRecognizer.application`.
     *
     * Note: Neither the LUIS Application ID nor the Endpoint Key are actual LUIS components, they are representations of what two valid values would appear as.
     */
    validateLuisApplication() {
        if (!this.application.applicationId) {
            throw new Error(`Invalid \`applicationId\` value detected: ${this.application.applicationId}\nPlease make sure your applicationId is a valid LUIS Application Id, e.g. "b31aeaf3-3511-495b-a07f-571fc873214b".`);
        }
        if (!this.application.endpointKey) {
            throw new Error(`Invalid \`endpointKey\` value detected: ${this.application.endpointKey}\nPlease make sure your endpointKey is a valid LUIS Endpoint Key, e.g. "048ec46dc58e495482b0c447cfdbd291".`);
        }
    }
}
exports.LuisRecognizer = LuisRecognizer;
//# sourceMappingURL=luisRecognizer.js.map