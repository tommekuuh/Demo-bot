"use strict";
/**
 * @module botbuilder-azure
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
const azure = require("azure-storage");
const querystring_1 = require("querystring");
const ContainerNameCheck = new RegExp('^[a-z0-9](?!.*--)[a-z0-9-]{1,61}[a-z0-9]$');
/**
 * @private
 * Unique ket used to access the static <code>checkedCollections</code>
 * property of the AzureBlobTranscriptStore. Accessing it is necessary for
 * proper testing and debugging.
 */
exports.checkedCollectionsKey = Symbol('checkedCollectionsKey');
/**
 * Stores transcripts in an Azure Blob container.
 *
 * @remarks
 * Each activity is stored as JSON blob with a structure of
 * `container/{channelId]/{conversationId}/{Timestamp.ticks}-{activity.id}.json`.
 */
class AzureBlobTranscriptStore {
    /**
     * Creates a new AzureBlobTranscriptStore instance.
     * @param settings Settings required for configuring an instance of BlobStorage
     */
    constructor(settings) {
        this.pageSize = 20;
        if (!settings) {
            throw new Error('The settings parameter is required.');
        }
        if (!settings.containerName) {
            throw new Error('The containerName is required.');
        }
        if (!this.checkContainerName(settings.containerName)) {
            throw new Error('Invalid container name.');
        }
        this.settings = { ...settings };
        this.client = this.createBlobService(this.settings);
    }
    /**
     * Log an activity to the transcript.
     * @param activity Activity being logged.
     */
    async logActivity(activity) {
        if (!activity) {
            throw new Error('Missing activity.');
        }
        const blobName = this.getBlobName(activity);
        const data = JSON.stringify(activity);
        const container = await this.ensureContainerExists();
        const block = await this.client.createBlockBlobFromTextAsync(container.name, blobName, data, null);
        const meta = this.client.setBlobMetadataAsync(container.name, blobName, {
            fromid: activity.from.id,
            recipientid: activity.recipient.id,
            timestamp: activity.timestamp.getTime().toString()
        });
        const props = this.client.setBlobPropertiesAsync(container.name, blobName, {
            contentType: 'application/json'
        });
        await Promise.all([block, meta, props]); // Concurrent
    }
    /**
     * Get activities for a conversation (Aka the transcript)
     * @param channelId Channel Id.
     * @param conversationId Conversation Id.
     * @param continuationToken Continuatuation token to page through results.
     * @param startDate Earliest time to include.
     */
    async getTranscriptActivities(channelId, conversationId, continuationToken, startDate) {
        if (!channelId) {
            throw new Error('Missing channelId');
        }
        if (!conversationId) {
            throw new Error('Missing conversationId');
        }
        if (!startDate) {
            startDate = new Date(0);
        }
        // tslint:disable-next-line:prefer-template
        const prefix = this.getDirName(channelId, conversationId) + '/';
        const token = null;
        const container = await this.ensureContainerExists();
        const activityBlobs = await this.getActivityBlobs([], container.name, prefix, continuationToken, startDate, token);
        const activities = await Promise.all(activityBlobs.map(blob => this.blobToActivity(blob)));
        const pagedResult = { items: activities, continuationToken: undefined };
        if (pagedResult.items.length === this.pageSize) {
            pagedResult.continuationToken = activityBlobs.slice(-1).pop().name;
        }
        return pagedResult;
    }
    /**
     * List conversations in the channelId.
     * @param channelId Channel Id.
     * @param continuationToken ContinuationToken token to page through results.
     */
    async listTranscripts(channelId, continuationToken) {
        if (!channelId) {
            throw new Error('Missing channelId');
        }
        // tslint:disable-next-line:prefer-template
        const prefix = this.getDirName(channelId) + '/';
        const token = null;
        const container = await this.ensureContainerExists();
        const transcripts = await this.getTranscriptsFolders([], container.name, prefix, continuationToken, channelId, token);
        const pagedResult = { items: transcripts, continuationToken: undefined };
        if (pagedResult.items.length === this.pageSize) {
            pagedResult.continuationToken = transcripts.slice(-1).pop().id;
        }
        return pagedResult;
    }
    /**
     * Delete a specific conversation and all of it's activities.
     * @param channelId Channel Id where conversation took place.
     * @param conversationId Id of the conversation to delete.
     */
    async deleteTranscript(channelId, conversationId) {
        if (!channelId) {
            throw new Error('Missing channelId');
        }
        if (!conversationId) {
            throw new Error('Missing conversationId');
        }
        // tslint:disable-next-line:prefer-template
        const prefix = this.getDirName(channelId, conversationId) + '/';
        const token = null;
        const container = await this.ensureContainerExists();
        const conversationBlobs = await this.getConversationsBlobs([], container.name, prefix, token);
        await Promise.all(conversationBlobs.map(blob => this.client.deleteBlobIfExistsAsync(blob.container, blob.name)));
    }
    async blobToActivity(blob) {
        const content = await this.client.getBlobToTextAsync(blob.container, blob.name);
        const activity = JSON.parse(content);
        activity.timestamp = new Date(activity.timestamp);
        return activity;
    }
    async getActivityBlobs(blobs, container, prefix, continuationToken, startDate, token) {
        const listBlobResult = await this.client.listBlobsSegmentedWithPrefixAsync(container, prefix, token, { include: 'metadata' });
        listBlobResult.entries.some(blob => {
            const timestamp = parseInt(blob.metadata.timestamp, 10);
            if (timestamp >= startDate.getTime()) {
                if (continuationToken) {
                    if (blob.name === continuationToken) {
                        continuationToken = null;
                    }
                }
                else {
                    blob.container = container;
                    blobs.push(blob);
                    return (blobs.length === this.pageSize);
                }
            }
            return false;
        });
        if (listBlobResult.continuationToken && blobs.length < this.pageSize) {
            await this.getActivityBlobs(blobs, container, prefix, continuationToken, startDate, listBlobResult.continuationToken);
        }
        return blobs;
    }
    async getTranscriptsFolders(transcripts, container, prefix, continuationToken, channelId, token) {
        const result = await this.client.listBlobDirectoriesSegmentedWithPrefixAsync(container, prefix, token);
        result.entries.some(blob => {
            const conversation = {
                channelId: channelId,
                id: blob.name.split('/').filter((part) => part).slice(-1).pop(),
                created: undefined
            };
            if (continuationToken) {
                if (conversation.id === continuationToken) {
                    continuationToken = null;
                }
            }
            else {
                transcripts.push(conversation);
                return (transcripts.length === this.pageSize);
            }
            return false;
        });
        if (result.continuationToken && transcripts.length < this.pageSize) {
            await this.getTranscriptsFolders(transcripts, container, prefix, continuationToken, channelId, result.continuationToken);
        }
        return transcripts;
    }
    async getConversationsBlobs(blobs, container, prefix, token) {
        const result = await this.client.listBlobsSegmentedWithPrefixAsync(container, prefix, token, null);
        blobs = blobs.concat(result.entries.map((blob) => {
            blob.container = container;
            return blob;
        }));
        if (result.continuationToken) {
            await this.getConversationsBlobs(blobs, container, prefix, result.continuationToken);
        }
        return blobs;
    }
    checkContainerName(container) {
        return ContainerNameCheck.test(container);
    }
    getBlobName(activity) {
        const channelId = this.sanitizeKey(activity.channelId);
        const conversationId = this.sanitizeKey(activity.conversation.id);
        const timestamp = this.sanitizeKey(this.getTicks(activity.timestamp));
        const activityId = this.sanitizeKey(activity.id);
        return `${channelId}/${conversationId}/${timestamp}-${activityId}.json`;
    }
    getDirName(channelId, conversationId) {
        if (!conversationId) {
            return this.sanitizeKey(channelId);
        }
        return `${this.sanitizeKey(channelId)}/${this.sanitizeKey(conversationId)}`;
    }
    sanitizeKey(key) {
        return querystring_1.escape(key);
    }
    getTicks(timestamp) {
        const epochTicks = 621355968000000000; // the number of .net ticks at the unix epoch
        const ticksPerMillisecond = 10000; // there are 10000 .net ticks per millisecond
        const ticks = epochTicks + (timestamp.getTime() * ticksPerMillisecond);
        return ticks.toString(16);
    }
    ensureContainerExists() {
        const key = this.settings.containerName;
        if (!AzureBlobTranscriptStore[exports.checkedCollectionsKey][key]) {
            AzureBlobTranscriptStore[exports.checkedCollectionsKey][key] = this.client.createContainerIfNotExistsAsync(key);
        }
        return AzureBlobTranscriptStore[exports.checkedCollectionsKey][key];
    }
    createBlobService({ storageAccountOrConnectionString, storageAccessKey, host }) {
        if (!storageAccountOrConnectionString) {
            throw new Error('The storageAccountOrConnectionString parameter is required.');
        }
        const blobService = azure.createBlobService(storageAccountOrConnectionString, storageAccessKey, host).withFilter(new azure.LinearRetryPolicyFilter(5, 500));
        // The perfect use case for a Proxy
        return new Proxy({}, {
            get(target, p) {
                const prop = p.toString().endsWith('Async') ? p.toString().replace('Async', '') : p;
                return target[p] || (target[p] = denodeify(blobService, blobService[prop]));
            }
        });
        function denodeify(thisArg, fn) {
            return (...args) => {
                return new Promise((resolve, reject) => {
                    args.push((error, result) => (error) ? reject(error) : resolve(result));
                    fn.apply(thisArg, args);
                });
            };
        }
    }
}
_a = exports.checkedCollectionsKey;
/**
 * @private
 * Internal dictionary with the containers where entities will be stored.
 */
AzureBlobTranscriptStore[_a] = {};
exports.AzureBlobTranscriptStore = AzureBlobTranscriptStore;
//# sourceMappingURL=azureBlobTranscriptStore.js.map